Disassembly Listing for EncoderInterface
Generated From:
C:/Users/bednarse/School/Fall 2020/ST Advanced Control Systems Integration/Project/Encoder Interface/EncoderInterface.X/dist/default/production/EncoderInterface.X.production.elf
Nov 13, 2020 4:19:50 PM

---  C:/Users/bednarse/School/Fall 2020/ST Advanced Control Systems Integration/Project/Encoder Interface/EncoderInterface.X/main.c
1:             /*******************************************************************
2:              * Program:     EncoderInterface
3:              * Device:      PIC16F15313
4:              * Created By:  Sam Bednarski
5:              * Created On:  11/13/2020
6:              * Revised By:  N/A
7:              * Revised On:  N/A
8:              * 
9:              * This program interfaces quadrature encoder counting over I2C.
10:             * Master reads in 4-byte signed integer, LS byte first.
11:             ********************************************************************/
12:            
13:            /**  Header Files **************************************************/
14:            #include <xc.h>
15:            #include <pic16f15313.h>
16:            
17:            /** Configuration Bits *********************************************/
18:            #pragma config FEXTOSC = OFF    // no external oscillator
19:            #pragma config RSTOSC = HFINT1  // high frequency internal oscillator
20:            #pragma config WDTE = OFF       // watchdog timer disabled
21:            #pragma config LVP = OFF        // low voltage programming disabled
22:            #pragma config BOREN = OFF      // brown-out reset disabled
23:            
24:            /** Local Function Prototypes **************************************/
25:            void __interrupt() isr(void);
26:            
27:            /** Constants ******************************************/
28:            #define WHEEL 0 // Left 0, Right 1
29:            
30:            #if WHEEL
31:            #define DIR 0   // wheel direction (fwd)
32:            #else
33:            #define DIR 1   // wheel direction (rev)
34:            #endif
35:            
36:            #if WHEEL
37:            #define PIC_I2C_ADDR 0x09   // PIC I2C address (right wheel)
38:            #else
39:            #define PIC_I2C_ADDR 0x08   // PIC I2C address (left wheel)
40:            #endif
41:            
42:            /** Global Variables ***********************************************/
43:            volatile long count = 0L;   // absolute position counter (reset 0)
44:            volatile long count_copy;   // counter copy for transmission
45:            volatile char old_enc;      // previous encoder state
46:            
47:            // Increment selection matrix [old][new] (definition depends on DIR)
48:            #if DIR
49:            const signed char inc_mat[4][4] = {{ 0,  1, -1,  0},
50:                                               {-1,  0,  0,  1},
51:                                               { 1,  0,  0, -1},
52:                                               { 0, -1,  1,  0}};   // flipped / reversed
53:            #else
54:            const signed char inc_mat[4][4] = {{ 0, -1,  1,  0},
55:                                               { 1,  0,  0, -1},
56:                                               {-1,  0,  0,  1},
57:                                               { 0,  1, -1,  0}};   // normal / forwards
58:            #endif
59:            
60:            /*******************************************************************
61:             * Function:        void main(void)
62:             ********************************************************************/
63:            int main(void) {
64:                // Oscillator Setup
65:                OSCCON1 = 0b1100000;    // HFINTOSC, no divisor
0091  3060     MOVLW 0x60
0092  0151     MOVLB 0x11
0093  008D     MOVWF OSCCON1
66:                OSCFRQ = 0b011;         // 8 MHz
0094  3003     MOVLW 0x3
0095  0093     MOVWF OSCFRQ
67:                
68:                // Pin IO Setup
69:                TRISA = 0b110111;   // set all input
0096  3037     MOVLW 0x37
0097  0140     MOVLB 0x0
0098  0092     MOVWF TRISA
70:                ANSELA = 0b000000;  // set all pins to digital
0099  017E     MOVLB 0x3E
009A  01B8     CLRF ANSELA
71:                SLRCONA = 0b000000; // set all slews to maximum rate
009B  01BB     CLRF SLRCONA
72:                ODCONA = 0b000110;  // configure RA1/SCL & RA2/SDA as open-drain
009C  3006     MOVLW 0x6
009D  00BA     MOVWF ODCONA
73:                
74:                // Peripheral Pin Select (PPS) Setup
75:                SSP1CLKPPS = 0b00001;   // Map SCL to RA1
009E  3001     MOVLW 0x1
009F  017D     MOVLB 0x3D
00A0  00C5     MOVWF SSP1CLKPPS
76:                SSP1DATPPS = 0b00010;   // Map SDA to RA2
00A1  3002     MOVLW 0x2
00A2  00C6     MOVWF SSP1DATPPS
77:                RA1PPS = 0x15;          // Map RA1 to SCL
00A3  3015     MOVLW 0x15
00A4  017E     MOVLB 0x3E
00A5  0091     MOVWF RA1PPS
78:                RA2PPS = 0x16;          // Map RA2 to SDA
00A6  3016     MOVLW 0x16
00A7  0092     MOVWF RA2PPS
79:                
80:                // Interrupt-On-Change (IOC) Setup
81:                IOCAP = 0b110000;   // RA4 & RA5 positive edge enabled
00A8  3030     MOVLW 0x30
00A9  00BD     MOVWF IOCAP
82:                IOCAN = 0b110000;   // RA4 & RA5 negative edge enabled
00AA  3030     MOVLW 0x30
00AB  00BE     MOVWF IOCAN
83:                
84:                // I2C Setup
85:                SSP1STAT = 0b11000000;          // slew rate control off, SMBus disabled
00AC  30C0     MOVLW 0xC0
00AD  0143     MOVLB 0x3
00AE  008F     MOVWF SSP1STAT
86:                SSP1CON1 = 0b00110110;          // enable MSSP, enable clock, I2C slave, 7-bit address
00AF  3036     MOVLW 0x36
00B0  0090     MOVWF SSP1CON1
87:                SSP1CON3 = 0b00000010;          // address hold enabled
00B1  3002     MOVLW 0x2
00B2  0092     MOVWF SSP1CON3
88:                SSP1ADD = PIC_I2C_ADDR << 1;    // set 7-bit address
00B3  3010     MOVLW 0x10
00B4  008D     MOVWF SSP1ADD
89:                
90:                // Initialize encoder state
91:                old_enc = PORTA >> 4;
00B5  0140     MOVLB 0x0
00B6  080C     MOVF PORTA, W
00B7  00A4     MOVWF __pcstackBANK0
00B8  3004     MOVLW 0x4
00B9  36A4     LSRF __pcstackBANK0, F
00BA  0B89     DECFSZ WREG, F
00BB  28B9     GOTO 0xB9
00BC  0824     MOVF __pcstackBANK0, W
00BD  00A5     MOVWF 0x25
00BE  0825     MOVF 0x25, W
00BF  00FB     MOVWF old_enc
92:                
93:                // Interrupt Setup
94:                PIE0bits.IOCIE = 1;     // enable IOC general interrupt
00C0  014E     MOVLB 0xE
00C1  1616     BSF PIE0, 0x4
95:                PIE3bits.SSP1IE = 1;    // enable MSSP interrupt
00C2  1419     BSF PIE3, 0x0
96:                INTCONbits.PEIE = 1;    // enable peripheral interrupts
00C3  170B     BSF INTCON, 0x6
97:                INTCONbits.GIE = 1;     // enable global interrupts
00C4  178B     BSF INTCON, 0x7
98:                
99:                // Infinite loop
100:               while(1);   // do nothing
00C5  28C5     GOTO 0xC5
00C6  2884     GOTO 0x84
101:           }
102:           
103:           /*****************************************************************
104:            * Function:        void isr(void)
105:            ******************************************************************/
106:           void __interrupt() isr(void) {
0004  147E     BSF 0x77E, 0x0
0005  3180     MOVLP 0x0
107:               char byte;  // temporary byte, multiple uses
108:               
109:               // Encoder update
110:               if(PIR0bits.IOCIF) {
0006  014E     MOVLB 0xE
0007  1E0C     BTFSS PIR0, 0x4
0008  280A     GOTO 0xA
0009  280B     GOTO 0xB
000A  2840     GOTO 0x40
111:                   byte = old_enc ^ (IOCAF >> 4);  // determine new encoder reading
000B  017E     MOVLB 0x3E
000C  083F     MOVF IOCAF, W
000D  00F0     MOVWF 0x1F70
000E  3004     MOVLW 0x4
000F  36F0     LSRF 0x1F70, F
0010  0B89     DECFSZ WREG, F
0011  280F     GOTO 0xF
0012  0870     MOVF 0x1F70, W
0013  067B     XORWF 0x1F7B, W
0014  00F1     MOVWF 0x1F71
0015  0871     MOVF 0x1F71, W
0016  00F6     MOVWF 0x1F76
112:                   
113:                   IOCAF = 0;          // clear individual flags
0017  01BF     CLRF IOCAF
114:                   PIR0bits.IOCIF = 0; // clear global flag
0018  014E     MOVLB 0xE
0019  120C     BCF PIR0, 0x4
115:                   
116:                   count += (long) inc_mat[old_enc][byte]; // increment counter
001A  087B     MOVF 0x77B, W
001B  00F0     MOVWF 0x770
001C  01F1     CLRF 0x771
001D  35F0     LSLF 0x770, F
001E  0DF1     RLF 0x771, F
001F  35F0     LSLF 0x770, F
0020  0DF1     RLF 0x771, F
0021  30C7     MOVLW 0xC7
0022  00F2     MOVWF 0x772
0023  3080     MOVLW 0x80
0024  00F3     MOVWF 0x773
0025  0870     MOVF 0x770, W
0026  0772     ADDWF 0x772, W
0027  00F4     MOVWF 0x774
0028  0871     MOVF 0x771, W
0029  3D73     ADDWFC 0x773, W
002A  00F5     MOVWF 0x775
002B  0876     MOVF 0x776, W
002C  0774     ADDWF 0x774, W
002D  0084     MOVWF FSR0L
002E  0875     MOVF 0x775, W
002F  1803     BTFSC STATUS, 0x0
0030  0A75     INCF 0x775, W
0031  0085     MOVWF FSR0H
0032  0800     MOVF INDF0, W
0033  0140     MOVLB 0x0
0034  07A0     ADDWF count, F
0035  3980     ANDLW 0x80
0036  1D03     BTFSS STATUS, 0x2
0037  30FF     MOVLW 0xFF
0038  3DA1     ADDWFC 0x21, F
0039  3DA2     ADDWFC 0x22, F
003A  3DA3     ADDWFC 0x23, F
117:                   old_enc = byte;                         // update encoder state
003B  0876     MOVF byte, W
003C  00F0     MOVWF __pcstackCOMMON
003D  0870     MOVF __pcstackCOMMON, W
003E  00FB     MOVWF old_enc
118:               }
003F  2882     GOTO 0x82
119:               
120:               // I2C request
121:               else if(PIR3bits.SSP1IF) {
0040  1C0F     BTFSS 0xF, 0x0
0041  2843     GOTO 0x43
0042  2844     GOTO 0x44
0043  2882     GOTO 0x82
122:                   PIR3bits.SSP1IF = 0;    // clear flag
0044  100F     BCF 0xF, 0x0
123:                   
124:                   // Address byte received
125:                   if(!SSP1STATbits.DA) {
0045  0143     MOVLB 0x3
0046  1A8F     BTFSC SSP1STAT, 0x5
0047  2849     GOTO 0x49
0048  284A     GOTO 0x4A
0049  2872     GOTO 0x72
126:                       // Holding address, master awaiting ACK
127:                       if(SSP1CON3bits.ACKTIM) {
004A  1F92     BTFSS SSP1CON3, 0x7
004B  284D     GOTO 0x4D
004C  284E     GOTO 0x4E
004D  285C     GOTO 0x5C
128:                           byte = SSP1BUF; // flush buffer, clear flag
004E  080C     MOVF SSP1BUF, W
129:                           
130:                           SSP1CON2bits.ACKDT = !SSP1STATbits.RW;  // clear ACK if request is for read
004F  1003     BCF STATUS, 0x0
0050  1D0F     BTFSS SSP1STAT, 0x2
0051  1403     BSF STATUS, 0x0
0052  1803     BTFSC STATUS, 0x0
0053  2855     GOTO 0x55
0054  2858     GOTO 0x58
0055  0143     MOVLB 0x3
0056  1691     BSF SSP1CON2, 0x5
0057  285A     GOTO 0x5A
0058  0143     MOVLB 0x3
0059  1291     BCF SSP1CON2, 0x5
131:                           SSP1CON1bits.CKP = 1;                   // release clock
005A  1610     BSF SSP1CON1, 0x4
132:                       }
005B  2882     GOTO 0x82
133:                       
134:                       // ACK sent, master awaiting data
135:                       else {
136:                           count_copy = count;             // copy counter for transmission
005C  0140     MOVLB 0x0
005D  0823     MOVF 0x23, W
005E  00FA     MOVWF 0x7A
005F  0822     MOVF 0x22, W
0060  00F9     MOVWF 0x79
0061  0821     MOVF 0x21, W
0062  00F8     MOVWF 0x78
0063  0820     MOVF count, W
0064  00F7     MOVWF count_copy
137:                           SSP1BUF = count_copy & 0xff;    // load buffer with counter LS byte
0065  0877     MOVF count_copy, W
0066  0143     MOVLB 0x3
0067  008C     MOVWF SSP1BUF
138:                           SSP1CON1bits.CKP = 1;           // release clock
0068  1610     BSF SSP1CON1, 0x4
139:                           
140:                           count_copy >>= 8;   // shift counter copy
0069  3008     MOVLW 0x8
006A  00F0     MOVWF 0x1F0
006B  37FA     ASRF 0x1FA, F
006C  0CF9     RRF 0x1F9, F
006D  0CF8     RRF 0x1F8, F
006E  0CF7     RRF 0x1F7, F
006F  0BF0     DECFSZ 0x1F0, F
0070  286B     GOTO 0x6B
0071  2882     GOTO 0x82
141:                       }
142:                   }
143:                   
144:                   // Continuing transmission, ACK received, master awaiting data
145:                   // NOTE: if more than 4 bytes requested, will send all 0's
146:                   else if(!SSP1CON2bits.ACKSTAT) {
0072  1B11     BTFSC SSP1CON2, 0x6
0073  2875     GOTO 0x75
0074  2876     GOTO 0x76
0075  2882     GOTO 0x82
147:                       SSP1BUF = count_copy & 0xff;    // load buffer with counter LS byte
0076  0877     MOVF 0x1F7, W
0077  008C     MOVWF SSP1BUF
148:                       SSP1CON1bits.CKP = 1;           // release clock
0078  1610     BSF SSP1CON1, 0x4
149:           
150:                       count_copy >>= 8;   // shift counter copy
0079  3008     MOVLW 0x8
007A  00F0     MOVWF 0x1F0
007B  37FA     ASRF 0x1FA, F
007C  0CF9     RRF 0x1F9, F
007D  0CF8     RRF 0x1F8, F
007E  0CF7     RRF 0x1F7, F
007F  0BF0     DECFSZ 0x1F0, F
0080  287B     GOTO 0x7B
0081  2882     GOTO 0x82
151:                   }
152:               }
153:           }
0082  107E     BCF 0x1FE, 0x0
0083  0009     RETFIE
---  C:/Users/bednarse/AppData/Local/Temp/sgt8.s  -------------------------------------------------------
0085  01F7     CLRF 0x1F7
0086  01F8     CLRF 0x1F8
0087  01F9     CLRF 0x1F9
0088  01FA     CLRF 0x1FA
0089  0140     MOVLB 0x0
008A  01A0     CLRF count
008B  01A1     CLRF 0x21
008C  01A2     CLRF 0x22
008D  01A3     CLRF 0x23
008E  107E     BCF 0x7E, 0x0
008F  0140     MOVLB 0x0
0090  2891     GOTO 0x91
